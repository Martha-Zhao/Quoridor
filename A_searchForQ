# -*- coding: utf-8 -*-
#A_search.py

import numpy as np
origin = (0,3)
end  = (6,3)        
class CreateBoard():
    def __init__(self,origin,end):
        a = np.array([0,1,1])
        b = np.array([0,-1,1])
        A = np.vstack((a,a,a,a,a,a,(0,1,-1)))
        B = np.vstack((b,b,b,b,b,b,(0,-1,-1)))
        A = np.hstack((A,A,A,A,A,A,B)) 
        self.board = A
        self.S = [origin] # occupied
        self.C = [origin] #root decided
        self.D = [] #no root available
        
        self.row = 7
        self.column = 7
        self.origin  = origin
        self.end = end
        
    def placeBlock(self,mode,x,y): #mode = 1 vertical mode = 2 horizon
        if mode == 1:
            self.board[x,y * 3 + 1] = -1
            self.board[x + 1,y * 3 + 1] = -1
        else:
            self.board[x,y * 3 + 2] = -1
            self.board[x,y * 3 + 5] = -1
        
myBoard = CreateBoard(origin,end) 
myBoard.placeBlock(1, 2, 3)
myBoard.placeBlock(0, 3, 3)  
myBoard.placeBlock(1, 2, 2)

class Piece:
    def __init__(self,location):
        self.location = location
        # neighbor
        self.neighbor = []
        self.distance = 0
        
        x = self.location[0]
        y = self.location[1]
        self.distance = end[0] - x + len(myBoard.C)
        
    def findNeighbor(self):
        x = self.location[0]
        y = self.location[1]
        if x - 1 >= 0 and myBoard.board[x - 1,y * 3] == 0 and myBoard.board[x - 1,y * 3 + 2] == 1:
            self.neighbor.append((x - 1,y))
        if x + 1 <= myBoard.row - 1 and myBoard.board[x + 1,y * 3] == 0 and myBoard.board[x,y * 3 + 2] == 1:
            self.neighbor.append((x + 1,y))
        if y - 1 >= 0 and myBoard.board[x,(y - 1) * 3] == 0 and myBoard.board[x,y * 3 - 2] == 1: 
            self.neighbor.append((x,y - 1))
        if y + 1 <= myBoard.column - 1 and myBoard.board[x,(y + 1) * 3] == 0 and myBoard.board[x,y * 3 + 1] == 1:
            self.neighbor.append((x,y + 1))
        for i in self.neighbor:
            if (i in myBoard.S) or (i in myBoard.C) or (i in myBoard.D):
                self.neighbor.remove(i)

#回溯法
# fatherPiece = origin
myPiece = Piece(origin) 

def searchPath():
    global myPiece
    while(myPiece.location[0] != 6):
        distance = 0x3f3f3f3f
        myPiece.findNeighbor()
        if myPiece.neighbor != []:
            for i in myPiece.neighbor:
                sonPiece = Piece(i)
                myBoard.S.append(i)
                if sonPiece.distance <= distance:
                    distance = sonPiece.distance
                    searchResult = i
            myBoard.C.append(searchResult)
            myPiece = Piece(searchResult)
            searchPath()
        else:
            myBoard.S.remove(myPiece.location)
            myBoard.C.remove(myPiece.location)
            myBoard.D.append(myPiece.location)
            myPiece = Piece(myBoard.C[len(myBoard.C) - 1])
#             myBoard.C.append(myPiece.location)

searchPath()
print(myBoard.C)            
            
