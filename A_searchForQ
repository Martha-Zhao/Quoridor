# -*- coding: utf-8 -*-
#A_search.py

import numpy as np
origin = (0,3)#original location of my pieces
end  = (6,3)   #target location of my pieces 
  
"""
create board (center,right,down) 
center:0 location available 
right down ---- -1: with block 1: no block
"""   
class CreateBoard():
    def __init__(self,origin,end):
        a = np.array([0,1,1]) 
        b = np.array([0,-1,1])
        A = np.vstack((a,a,a,a,a,a,(0,1,-1)))
        B = np.vstack((b,b,b,b,b,b,(0,-1,-1)))
        A = np.hstack((A,A,A,A,A,A,B)) 
 
        self.board = A  
        self.S = [origin] # occupied
        self.C = [origin] #root decided
        self.D = [] #no root available
        
        self.row = 7
        self.column = 7
        self.origin  = origin
        self.end = end
    
    """
    mode = 1 vertical mode = 2 horizon
    (x,y) center of block
    """    
    def placeBlock(self,mode,x,y): 
        if mode == 1:     
            self.board[x,y * 3 + 1] = -1
            self.board[x + 1,y * 3 + 1] = -1
        else:
            self.board[x,y * 3 + 2] = -1
            self.board[x,y * 3 + 5] = -1
        
myBoard = CreateBoard(origin,end) # initialization my board
"""
place blocks test
"""
myBoard.placeBlock(1, 2, 3) 
myBoard.placeBlock(0, 3, 3)  
myBoard.placeBlock(1, 2, 2)


"""
class Piece:
location: location of  piece
neighbor:left right up down remove:location occupied and with blocks
distance: real step up to now and vertical distance end[0] - location[0]
function: findNeighbor find all neighbors not occupied and remove blocked
p.s. search from end to begin to avoid index jump 
"""
class Piece:
    def __init__(self,location):
        self.location = location
        # neighbor
        self.neighbor = []
        self.distance = 0
        
        x = self.location[0]
        y = self.location[1] #test variable
        self.distance = end[0] - x + len(myBoard.C)
        
    def findNeighbor(self):
        x = self.location[0]
        y = self.location[1]
        if y - 1 >= 0 and myBoard.board[x,(y - 1) * 3] == 0 and myBoard.board[x,y * 3 - 2] == 1: 
            self.neighbor.append((x,y - 1))
        if y + 1 <= myBoard.column - 1 and myBoard.board[x,(y + 1) * 3] == 0 and myBoard.board[x,y * 3 + 1] == 1:
            self.neighbor.append((x,y + 1))
        if x - 1 >= 0 and myBoard.board[x - 1,y * 3] == 0 and myBoard.board[x - 1,y * 3 + 2] == 1:
            self.neighbor.append((x - 1,y))
        if x + 1 <= myBoard.row - 1 and myBoard.board[x + 1,y * 3] == 0 and myBoard.board[x,y * 3 + 2] == 1:
            self.neighbor.append((x + 1,y))
        
        for i in reversed(self.neighbor):
            if (i in myBoard.C) or (i in myBoard.D):
                self.neighbor.remove(i)

#回溯法
myPiece = Piece(origin)# initialization my piece  

"""
A* find route
father location in list myBoard.C
son location in myPiece.neighbor
location tested in list myBoard.S
dead route in list myBoard.D
distance : shortest route among son piece  
search with backTracking
"""

def searchPath():
    global myPiece
    while(myPiece.location[0] != 6):
        distance = 0x3f3f3f3f
        myPiece.findNeighbor()
        if myPiece.neighbor != []:
            for i in myPiece.neighbor:
                sonPiece = Piece(i)
                myBoard.S.append(i)
                if sonPiece.distance <= distance:
                    distance = sonPiece.distance
                    searchResult = i
            myBoard.C.append(searchResult)
            myPiece = Piece(searchResult)
            searchPath()
        else:
            myBoard.S.remove(myPiece.location)
            myBoard.C.remove(myPiece.location)
            myBoard.D.append(myPiece.location)
            myPiece = Piece(myBoard.C[-1])
#             myPiece = Piece(myBoard.S[-1])
#             myBoard.C.append(myPiece.location)


#main function
searchPath()
print(myBoard.C) #print result  
            
